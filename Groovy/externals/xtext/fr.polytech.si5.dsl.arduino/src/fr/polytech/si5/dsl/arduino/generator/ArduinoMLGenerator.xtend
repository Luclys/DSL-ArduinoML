/*
 * generated by Xtext 2.23.0
 */
package fr.polytech.si5.dsl.arduino.generator

import fr.polytech.si5.dsl.arduino.arduinoML.Action
import fr.polytech.si5.dsl.arduino.arduinoML.Actuator
import fr.polytech.si5.dsl.arduino.arduinoML.App
import fr.polytech.si5.dsl.arduino.arduinoML.Brick
import fr.polytech.si5.dsl.arduino.arduinoML.Sensor
import fr.polytech.si5.dsl.arduino.arduinoML.State
import fr.polytech.si5.dsl.arduino.arduinoML.Transition
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ArduinoMLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var Object root = resource.contents.get(0);
		if (! (root instanceof App)){
			return
		}
		var App app = root as App
		fsa.generateFile(app.name+'.ino', compile(app))
	}
		
	def compile(App app) '''
		//Wiring code generated from an ArduinoML model
		// Application name: «app.name»"

		long debounce = 200;
		enum STATE {«app.states.map[name].join(', ')»};
		
		«IF app.initial !== null »
			STATE currentState = «app.initial.name»;
		«ENDIF»

		«FOR Brick brick: app.bricks»
			«declare(brick)»
		«ENDFOR»

		void setup(){
		«FOR Brick brick: app.getBricks()»
				«compile(brick)»
		«ENDFOR»
		}

		void loop() {
			switch(currentState){
			«FOR State state: app.states»
				«compile(state)»
			«ENDFOR»
			}
		}
	'''

	def declare(Brick b) '''
		«IF b instanceof Sensor»
			«declare(b as Sensor)»
		«ENDIF»
	'''
	def compile(Brick b) '''
	«switch b {
		Actuator: compile(b as Actuator)
		Sensor: compile(b as Sensor)
	  }
	»
	'''

	def compile(Actuator actuator) '''
		pinMode(«actuator.pin», OUTPUT); // «actuator.name» [Actuator]
	'''
	
	def declare(Sensor sensor) '''
			boolean «sensor.name»BounceGuard = false;
			long «sensor.name»LastDebounceTime = 0;
	'''

	def compile(Sensor sensor) '''
		pinMode(«sensor.pin», INPUT);  // «sensor.name» [Sensor]
	'''

	def compile(State state) '''
				case «state.name»:
					«FOR Action action : state.actions»
						«compile(action)»
					«ENDFOR»
					«IF (state.transition !== null)»
					«compile(state.transition)»
					break;
			«ENDIF»
	'''

	def compile(Transition transition) '''
				«transition.sensor.name»BounceGuard = millis() - «transition.sensor.name»LastDebounceTime > debounce;
				if( digitalRead(«transition.sensor.pin») == «transition.value» && «transition.sensor.name»BounceGuard) {
					«transition.sensor.name»LastDebounceTime = millis();
					currentState = «transition.next.name»;
				}
	'''

	def compile(Action action) '''
			digitalWrite(«action.actuator.pin»,«action.value»);
	'''
	
}
