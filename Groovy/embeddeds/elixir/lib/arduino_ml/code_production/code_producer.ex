defmodule ArduinoML.CodeProducer do

  alias ArduinoML.Application, as: Application

  @doc """
  Returns a string which is the representation in C code of the application.
  """
  def to_code(application = %Application{sensors: sensors, actuators: actuators}) do
    application = Application.enhanced(application)
    
    """
    // generated by ArduinoML #Elixir.

    // Bricks <~> Pins.
    #{sensors ++ actuators |> Enum.map(&brick_declaration/1) |> Enum.join("\n")}
    
    // Setup the inputs and outputs.
    void setup() {
    #{sensors |> Enum.map(fn s -> "  " <> brick_setup(s, "INPUT") end) |> Enum.join("\n")}

    #{actuators |> Enum.map(fn s -> "  " <> brick_setup(s, "OUTPUT") end) |> Enum.join("\n")}
    }

    // Static setup code.
    int currentState = #{Application.state_position(application, application.initial.label)};

    // States declarations.
    #{application.states |> Enum.map(fn state -> state_function(state, application) end) |> Enum.join("\n")}
    // This function specifies the first state.
    #{loop_function(application)}
    """
  end

  defp brick_declaration(%{label: label, pin: pin}), do: "int #{brick(label)} = #{pin(pin)};"

  defp brick_setup(%{label: label}, stream), do: "pinMode(#{brick(label)}, #{stream});"

  defp state_function(state = %{label: label, actions: actions}, application) do
    relevant_transitions = Enum.filter(application.transitions, fn %{from: %{label: from_label}} -> from_label == label end)

    actions_lines = actions
    |> Enum.map(fn action -> action_statement(action) end)
    |> Enum.map(&("  " <> &1))
    |> Enum.join("\n")
    
    """
    void #{state_function_name(state)}() {
    #{actions_lines}
    
    #{transitions_declaration(application, relevant_transitions)}
    }
    """
  end

  # It calls a write function on an actuator and a signal.
  defp action_statement(%{actuator: %{label: label, type: type}, signal: signal}) do
    "#{write_function(type)}(#{brick(label)}, #{signal(signal)});"
  end
  
  defp transitions_declaration(application, transitions) do
    transitions_declaration(application, transitions, true)
  end

  defp transitions_declaration(_, [], _), do: ""
  defp transitions_declaration(application, [%{to: to, on: assertions} | others], is_first) do
    condition = assertions
    |> Enum.map(&(condition(&1)))
    |> Enum.join(" && ")
    
    "#{condition_keyword(is_first)} (#{condition}) {\n" <>
    "    #{state_change(application, to)}\n" <>
    "  }" <> transitions_declaration(application, others, false)
  end
  
  defp condition_keyword(false), do: " else if"
  defp condition_keyword(true), do: "  if"

  defp comparison(:equals), do: "=="
  defp comparison(:lower_than), do: "<"
  defp comparison(:greater_than), do: ">"

  defp condition(%{sensor: sensor, signal: signal, comparison: sign}), do: "#{signal(sensor)} #{comparison(sign)} #{signal(signal)}"

  defp loop_function(application) do
    "void loop() {\n" <>
    "  #{loop_content(application, application.states)}\n" <>
    "}"
  end

  defp loop_content(_, []), do: "{\n    /* Not supposed to arrive here. */\n  }"
  defp loop_content(application, [current_state | others]) do
    position = Application.state_position(application, current_state.label)
    state_call = state_function_name(current_state) <> "();"
    "if (currentState == #{position}) {
    #{state_call}
  } else #{loop_content(application, others)}"
  end
  
  defp write_function(:digital), do: "digitalWrite"
  defp write_function(:analogic), do: "analogWrite"

  defp read_function(:digital), do: "digitalRead"
  defp read_function(:analogic), do: "analogRead"
  
  defp state_function_name(%{label: label}), do: "state_" <> state(label)

  defp state(label) when is_atom(label), do: label |> Atom.to_string |> String.downcase
  defp state(label) when is_binary(label), do: String.downcase(label)

  defp brick(label) when is_atom(label), do: label |> Atom.to_string |> String.upcase
  defp brick(label) when is_binary(label), do: String.upcase(label)

  defp signal(label) when label in [:low, :high], do: label |> Atom.to_string |> String.upcase
  defp signal(label) when is_integer(label), do: Integer.to_string(label)
  defp signal(%{label: label, type: type}) do
    "#{read_function(type)}(#{brick(label)})"
  end
    
  defp pin(value) when is_integer(value), do: Integer.to_string(value)

  defp state_change(application = %Application{}, state = %ArduinoML.State{}) do
    position = Application.state_position(application, state.label)
    
    "currentState = #{position};"
  end
end
