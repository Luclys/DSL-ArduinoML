The example we use is the one described [here](https://github.com/mosser/ArduinoML-kernel/blob/master/README.md)
and [here](https://github.com/mosser/ArduinoML-kernel/blob/master/docs/README.md)

The resulting Arduino code is:

```c
// generated by ArduinoML

int BUTTON = 9;
int LED = 12;

void setup() {
	pinMode(BUTTON, INPUT);
	pinMode(LED, OUTPUT);
}

int state = LOW; int prev = HIGH;
long time = 0; long debounce = 200;

void state_off() {
	digitalWrite(LED, LOW);
	boolean guard =  millis() - time > debounce;
	if (digitalRead(BUTTON) == HIGH && guard) {
		time = millis(); state_on();
	} else {
		state_off();
	}
}

void state_on() {
	digitalWrite(LED, HIGH);
	boolean guard =  millis() - time > debounce;
	if (digitalRead(BUTTON) == HIGH && guard) {
		time = millis(); state_off();
	} else {
		state_on();
	}
}

void loop() { state_off(); }
```

Alternatives:

- [No DSL](#nodsl) for reference

- [DSL with Builder+MethodChaining Patterns](#methodchaining)
 
## <a name="nodsl">No DSL</a>

The direct use of the model in Python is quite verbose.

```python
[... imports ...]

button = Sensor("BUTTON", 9)
led = Actuator("LED", 12)

on = State("on", [Action(HIGH, led)])
off = State("off", [Action(LOW, led)])

switchon = Transition(button, HIGH, on)
switchoff = Transition(button, HIGH, off)

on.settransition(switchoff)
off.settransition(switchon)

app = App("Switch!", [button, led], [off, on])

print app
```

In a shell:

1. go to the `embeddeds/python` directory
2. run the python interpreter, `python`, and type:


	```bash
	>>> from pyArduinoML.model.Main import demo
	>>> demo()
	```
	
3. alternatively to 2 you can run directly:

	```bash
	python -m pyArduinoML.model.Main
	```

## <a name="methodchaining">DSL with Builder+MethodChaining Patterns</a>

It is simpler with a DSL based on the [Builder](https://en.wikipedia.org/wiki/Builder_pattern) and [MethodChaining](https://en.wikipedia.org/wiki/Method_chaining) patterns.

```python
[... imports ...]

app = AppBuilder("Switch!") \
    .sensor("BUTTON").on_pin(9) \
    .actuator("LED").on_pin(12) \
    .state("off") \
        .set("LED").to(LOW) \
        .when("BUTTON").has_value(HIGH).go_to_state("on") \
    .state("on") \
        .set("LED").to(HIGH) \
        .when("BUTTON").has_value(HIGH).go_to_state("off") \
    .get_contents()

print app
```

A slight variation is to use python `eval` construct to avoid some syntactic sugar (line breaks).

```python
[... imports ...]

app2 = AppStringBuilder("""
AppBuilder("Switch!")
    .sensor("BUTTON").on_pin(9)
    .actuator("LED").on_pin(12)
    .state("off")
        .set("LED").to(LOW)
        .when("BUTTON").has_value(HIGH).go_to_state("on")
    .state("on")
        .set("LED").to(HIGH)
        .when("BUTTON").has_value(HIGH).go_to_state("off")
""")

print app2
```

Or course, there, you loose auto-completion (which is anyway limited in IDEs for python due to the typing mechanisms)

In a shell:

1. go to the `embeddeds/python` directory
2. run the python interpreter, `python`, and type:


	```bash
	>>> from pyArduinoML.methodchaining.Main import *
	>>> demo1() # for the first example
	>>> demo2() # for the variation
	```
	
3. alternatively to 2 you can run directly:

	```bash
	python -m pyArduinoML.methodchaining.Main
	```
